{"version":3,"file":"client.umd.js","sources":["../node_modules/nanoid/url-alphabet/index.cjs","../node_modules/nanoid/index.cjs","../node_modules/url-join/lib/url-join.js","../client/index.js"],"sourcesContent":["// This alphabet uses `A-Za-z0-9_-` symbols. The genetic algorithm helped\n// optimize the gzip compression for this alphabet.\nlet urlAlphabet =\n  'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW'\n\nmodule.exports = { urlAlphabet }\n","let crypto = require('crypto')\n\nlet { urlAlphabet } = require('./url-alphabet/index.cjs')\n\n// It is best to make fewer, larger requests to the crypto module to\n// avoid system call overhead. So, random numbers are generated in a\n// pool. The pool is a Buffer that is larger than the initial random\n// request size by this multiplier. The pool is enlarged if subsequent\n// requests exceed the maximum buffer size.\nconst POOL_SIZE_MULTIPLIER = 32\nlet pool, poolOffset\n\nlet random = bytes => {\n  if (!pool || pool.length < bytes) {\n    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  } else if (poolOffset + bytes > pool.length) {\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  }\n\n  let res = pool.subarray(poolOffset, poolOffset + bytes)\n  poolOffset += bytes\n  return res\n}\n\nlet customRandom = (alphabet, size, getRandom) => {\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\n  // values closer to the alphabet size. The bitmask calculates the closest\n  // `2^31 - 1` number, which exceeds the alphabet size.\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  // Though, the bitmask solution is not perfect since the bytes exceeding\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\n  // the random bytes redundancy has to be satisfied.\n\n  // Note: every hardware random generator call is performance expensive,\n  // because the system call for entropy collection takes a lot of time.\n  // So, to avoid additional system calls, extra bytes are requested in advance.\n\n  // Next, a step determines how many random bytes to generate.\n  // The number of random bytes gets decided upon the ID size, mask,\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\n  // according to benchmarks).\n  let step = Math.ceil((1.6 * mask * size) / alphabet.length)\n\n  return () => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      // A compact alternative for `for (var i = 0; i < step; i++)`.\n      let i = step\n      while (i--) {\n        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\n\nlet customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)\n\nlet nanoid = (size = 21) => {\n  let bytes = random(size)\n  let id = ''\n  // A compact alternative for `for (var i = 0; i < step; i++)`.\n  while (size--) {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    id += urlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n\nmodule.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n","(function (name, context, definition) {\n  if (typeof module !== 'undefined' && module.exports) module.exports = definition();\n  else if (typeof define === 'function' && define.amd) define(definition);\n  else context[name] = definition();\n})('urljoin', this, function () {\n\n  function normalize (strArray) {\n    var resultArray = [];\n    if (strArray.length === 0) { return ''; }\n\n    if (typeof strArray[0] !== 'string') {\n      throw new TypeError('Url must be a string. Received ' + strArray[0]);\n    }\n\n    // If the first part is a plain protocol, we combine it with the next part.\n    if (strArray[0].match(/^[^/:]+:\\/*$/) && strArray.length > 1) {\n      var first = strArray.shift();\n      strArray[0] = first + strArray[0];\n    }\n\n    // There must be two or three slashes in the file protocol, two slashes in anything else.\n    if (strArray[0].match(/^file:\\/\\/\\//)) {\n      strArray[0] = strArray[0].replace(/^([^/:]+):\\/*/, '$1:///');\n    } else {\n      strArray[0] = strArray[0].replace(/^([^/:]+):\\/*/, '$1://');\n    }\n\n    for (var i = 0; i < strArray.length; i++) {\n      var component = strArray[i];\n\n      if (typeof component !== 'string') {\n        throw new TypeError('Url must be a string. Received ' + component);\n      }\n\n      if (component === '') { continue; }\n\n      if (i > 0) {\n        // Removing the starting slashes for each component but the first.\n        component = component.replace(/^[\\/]+/, '');\n      }\n      if (i < strArray.length - 1) {\n        // Removing the ending slashes for each component but the last.\n        component = component.replace(/[\\/]+$/, '');\n      } else {\n        // For the last component we will combine multiple slashes to a single one.\n        component = component.replace(/[\\/]+$/, '/');\n      }\n\n      resultArray.push(component);\n\n    }\n\n    var str = resultArray.join('/');\n    // Each input component is now separated by a single slash except the possible first plain protocol part.\n\n    // remove trailing slash before parameters or hash\n    str = str.replace(/\\/(\\?|&|#[^!])/g, '$1');\n\n    // replace ? in parameters with &\n    var parts = str.split('?');\n    str = parts.shift() + (parts.length > 0 ? '?': '') + parts.join('&');\n\n    return str;\n  }\n\n  return function () {\n    var input;\n\n    if (typeof arguments[0] === 'object') {\n      input = arguments[0];\n    } else {\n      input = [].slice.call(arguments);\n    }\n\n    return normalize(input);\n  };\n\n});\n","const {\r\n\tnanoid\r\n} = require('nanoid')\r\n\r\nconst urljoin = require('url-join')\r\n\r\nclass Client {\r\n\r\n\tconstructor(path = '/sse', key = nanoid()) {\r\n\t\tthis.events = new Map()\r\n\r\n\t\tconst fullPath = urljoin(path, key)\r\n\r\n\t\tthis.eventSource = new EventSource(fullPath)\r\n\t\tthis.key = key\r\n\r\n\t\tthis.eventSource.addEventListener('open', this.onOpen.bind(this))\r\n\t\tthis.eventSource.addEventListener('error', this.onError.bind(this))\r\n\t\tthis.eventSource.addEventListener('close', this.onClose.bind(this))\r\n\t}\r\n\r\n\tget headers() {\r\n\t\treturn {\r\n\t\t\t'sse-key-e5b6a1db': this.key\r\n\t\t}\r\n\t}\r\n\r\n\t// addSSEHeadersToAxiosClient(axiosInstance) {\r\n\t// \taxiosInstance.interceptors.request.use(config => {\r\n\t// \t\tconfig.headers['sse-key'] = this.key\r\n\t// \t\treturn config\r\n\t// \t})\r\n\t// }\r\n\r\n\tonOpen(event) {\r\n\t\t// console.log('onOpen')\r\n\t}\r\n\r\n\tonError(event) {\r\n\t\t// console.log('client onError called')\r\n\t}\r\n\r\n\tonClose(event) {\r\n\t\tthis.eventSource.close()\r\n\t\tthis.eventSource = null\r\n\t}\r\n\r\n\taddEventListener(eventName, _callback) {\r\n\r\n\t\t// this assumes a single listener for each event\r\n\r\n\t\tconst callback = event => {\r\n\t\t\tconst type = event.type\r\n\t\t\tconst data = JSON.parse(event.data)\r\n\r\n\t\t\t_callback({\r\n\t\t\t\ttype,\r\n\t\t\t\tdata\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tthis.removeEventListener(eventName)\r\n\t\tthis.events.set(eventName, callback)\r\n\t\tthis.eventSource.addEventListener(eventName, callback)\r\n\t}\r\n\r\n\tremoveEventListener(eventName) {\r\n\t\tconst callback = this.events.get(eventName)\r\n\r\n\t\tif (callback) {\r\n\t\t\tthis.events.delete(eventName)\r\n\t\t\tthis.eventSource.removeEventListener(eventName, callback)\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nmodule.exports = Client"],"names":["pool","poolOffset","urlAlphabet","random","bytes","length","Buffer","allocUnsafe","crypto","randomFillSync","res","subarray","size","id","context","definition","this","normalize","strArray","resultArray","TypeError","match","first","shift","replace","i","component","push","str","join","parts","split","_typeof","arguments","slice","call","module","exports","nanoid","require$$0","path","key","events","Map","fullPath","urljoin","eventSource","EventSource","addEventListener","onOpen","bind","onError","onClose","event","close","eventName","_callback","callback","type","data","JSON","parse","removeEventListener","set","get"],"mappings":"m9DAEA,ICQIA,EAAMC,EARJC,EDCJ,mECSEC,EAAS,SAAAC,IACNJ,GAAQA,EAAKK,OAASD,GACzBJ,EAAOM,OAAOC,YALW,GAKCH,GAC1BI,UAAOC,eAAeT,GACtBC,EAAa,GACJA,EAAaG,EAAQJ,EAAKK,SACnCG,UAAOC,eAAeT,GACtBC,EAAa,OAGXS,EAAMV,EAAKW,SAASV,EAAYA,EAAaG,UACjDH,GAAcG,EACPM,KAwCI,mBAACE,yDAAO,GACfR,EAAQD,EAAOS,GACfC,EAAK,GAEFD,KAMLC,GAAMX,EAA0B,GAAdE,EAAMQ,WAEnBC,2OC5EQC,EAASC,EAATD,EAIHE,EAJYD,EAIN,oBAETE,EAAWC,OACdC,EAAc,MACM,IAApBD,EAASb,aAAuB,MAET,iBAAhBa,EAAS,SACZ,IAAIE,UAAU,kCAAoCF,EAAS,OAI/DA,EAAS,GAAGG,MAAM,iBAAmBH,EAASb,OAAS,EAAG,KACxDiB,EAAQJ,EAASK,QACrBL,EAAS,GAAKI,EAAQJ,EAAS,GAI7BA,EAAS,GAAGG,MAAM,gBACpBH,EAAS,GAAKA,EAAS,GAAGM,QAAQ,gBAAiB,UAEnDN,EAAS,GAAKA,EAAS,GAAGM,QAAQ,gBAAiB,aAGhD,IAAIC,EAAI,EAAGA,EAAIP,EAASb,OAAQoB,IAAK,KACpCC,EAAYR,EAASO,MAEA,iBAAdC,QACH,IAAIN,UAAU,kCAAoCM,GAGxC,KAAdA,IAEAD,EAAI,IAENC,EAAYA,EAAUF,QAAQ,SAAU,KAIxCE,EAFED,EAAIP,EAASb,OAAS,EAEZqB,EAAUF,QAAQ,SAAU,IAG5BE,EAAUF,QAAQ,SAAU,KAG1CL,EAAYQ,KAAKD,QAIfE,EAAMT,EAAYU,KAAK,KAOvBC,GAHJF,EAAMA,EAAIJ,QAAQ,kBAAmB,OAGrBO,MAAM,YACtBH,EAAME,EAAMP,SAAWO,EAAMzB,OAAS,EAAI,IAAK,IAAMyB,EAAMD,KAAK,YAK3D,kBASEZ,EANqB,WAAxBe,EAAOC,UAAU,IACXA,UAAU,GAEV,GAAGC,MAAMC,KAAKF,cAtEWG,EAAOC,QAASD,UAAiBrB,IAEjED,EAAO,QAASC,OCFtBuB,EACGC,gCAMSC,yDAAO,OAAQC,yDAAMH,mBAC3BI,OAAS,IAAIC,QAEZC,EAAWC,EAAQL,EAAMC,QAE1BK,YAAc,IAAIC,YAAYH,QAC9BH,IAAMA,OAENK,YAAYE,iBAAiB,OAAQhC,KAAKiC,OAAOC,KAAKlC,YACtD8B,YAAYE,iBAAiB,QAAShC,KAAKmC,QAAQD,KAAKlC,YACxD8B,YAAYE,iBAAiB,QAAShC,KAAKoC,QAAQF,KAAKlC,mDAG9D,iBACQ,oBACcA,KAAKyB,2BAW3B,SAAOY,2BAIP,SAAQA,2BAIR,SAAQA,QACFP,YAAYQ,aACZR,YAAc,qCAGpB,SAAiBS,EAAWC,OAIrBC,EAAW,SAAAJ,OACVK,EAAOL,EAAMK,KACbC,EAAOC,KAAKC,MAAMR,EAAMM,MAE9BH,EAAU,CACTE,KAAAA,EACAC,KAAAA,UAIGG,oBAAoBP,QACpBb,OAAOqB,IAAIR,EAAWE,QACtBX,YAAYE,iBAAiBO,EAAWE,sCAG9C,SAAoBF,OACbE,EAAWzC,KAAK0B,OAAOsB,IAAIT,GAE7BE,SACEf,cAAca,QACdT,YAAYgB,oBAAoBP,EAAWE"}